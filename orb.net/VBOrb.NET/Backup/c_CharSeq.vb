Option Strict Off
Option Explicit On
<System.Runtime.InteropServices.ProgId("c_CharSeq_NET.c_CharSeq")> Public Class c_CharSeq
	'Generated by IDL2VB v123. Copyright (c) 1999-2003 Martin.Both
	'Source File Name: ../include/CORBA.idl
	'Target File Name: c_CharSeq.cls
	
	
	'IDL Name: sequence<char>
	
	Private seqLen As Integer
	Private seqBnd As Integer
	Private seqArr() As Byte
	Private seqIsDim As Boolean
	
	
	Public Property Length() As Integer
		Get
			Length = seqLen
		End Get
		Set(ByVal Value As Integer)
			On Error GoTo ErrHandler
			Dim newSize As Integer
			If Value <= 0 Then
				seqLen = 0
				Erase seqArr
				seqIsDim = False
			Else
				If seqBnd > 0 And Value > seqBnd Then
					Call mVBOrb.VBOrb.raiseBADPARAM(1, mVBOrb.VBOrb.CompletedNO, CStr(Value) & " > " & CStr(seqBnd))
				End If
				seqLen = Value
				If seqIsDim Then
					If Value > UBound(seqArr) + 1 Then
						newSize = (UBound(seqArr) * 3 + 3) \ 2
						If seqBnd > 0 And newSize > seqBnd Then
							newSize = seqBnd
						End If
						If Value > newSize Then
							newSize = Value
						End If
						ReDim Preserve seqArr(newSize - 1)
					End If
				Else
					ReDim seqArr(Value - 1)
					seqIsDim = True
				End If
			End If
			Exit Property
ErrHandler: 
			Call mVBOrb.VBOrb.ErrReraise(Err, "CharSeq.Length.Let")
		End Set
	End Property
	
	Public ReadOnly Property Boundary() As Integer
		Get
			Boundary = seqBnd
		End Get
	End Property
	
	'index must be in the range of 0 to Length - 1
	
	'index must be in the range of 0 to Length - 1
	Public Property Item(ByVal index As Integer) As Byte
		Get
			On Error GoTo ErrHandler
			Item = seqArr(index)
			Exit Property
ErrHandler: 
			Call mVBOrb.VBOrb.ErrReraise(Err, "CharSeq.Item.Get")
		End Get
		Set(ByVal Value As Byte)
			On Error GoTo ErrHandler
			seqArr(index) = Value
			Exit Property
ErrHandler: 
			Call mVBOrb.VBOrb.ErrReraise(Err, "CharSeq.Item.Let")
		End Set
	End Property
	
	Public Function getItems(ByRef Arr() As Byte) As Integer
		On Error GoTo ErrHandler
		getItems = seqLen
		Dim seqCnt As Integer
		For seqCnt = 0 To seqLen - 1
			Arr(LBound(Arr) + seqCnt) = seqArr(seqCnt)
		Next seqCnt
		Exit Function
ErrHandler: 
		Call mVBOrb.VBOrb.ErrReraise(Err, "getItems")
	End Function
	
	Public Sub setItems(ByRef Arr() As Byte, ByVal newLen As Integer)
		On Error GoTo ErrHandler
		Me.Length = newLen
		Dim seqCnt As Integer
		For seqCnt = 0 To seqLen - 1
			seqArr(seqCnt) = Arr(LBound(Arr) + seqCnt)
		Next seqCnt
		Exit Sub
ErrHandler: 
		Call mVBOrb.VBOrb.ErrReraise(Err, "setItems")
	End Sub
	
	'Helper
	Public Sub initByRead(ByVal oIn As cOrbStream, ByVal maxLen As Integer)
		On Error GoTo ErrHandler
		seqBnd = maxLen
		Dim newLen As Integer
		newLen = oIn.readUlong()
		If seqBnd > 0 And newLen > seqBnd Then
			Call mVBOrb.VBOrb.raiseMARSHAL(1, mVBOrb.VBOrb.CompletedNO, CStr(newLen) & " > " & CStr(seqBnd))
		End If
		seqIsDim = False
		Me.Length = newLen
		Call oIn.readChars(seqArr, seqLen)
		Exit Sub
ErrHandler: 
		Call mVBOrb.VBOrb.ErrReraise(Err, "CharSeq.read")
	End Sub
	
	'Helper
	Public Sub writeMe(ByVal oOut As cOrbStream, ByVal maxLen As Integer)
		On Error GoTo ErrHandler
		seqBnd = maxLen
		If seqBnd > 0 And seqLen > seqBnd Then
			Call mVBOrb.VBOrb.raiseMARSHAL(1, mVBOrb.VBOrb.CompletedNO, CStr(seqLen) & " > " & CStr(seqBnd))
		End If
		Call oOut.writeUlong(seqLen)
		Call oOut.writeChars(seqArr, seqLen)
		Exit Sub
ErrHandler: 
		Call mVBOrb.VBOrb.ErrReraise(Err, "CharSeq.write")
	End Sub
	
	'Helper
	Public Sub initByAny(ByVal oAny As cOrbAny)
		On Error GoTo ErrHandler
		seqBnd = oAny.getOrigType.Length()
		Dim newLen As Integer
		newLen = oAny.seqGetLength()
		If seqBnd > 0 And newLen > seqBnd Then
			Call mVBOrb.VBOrb.raiseMARSHAL(1, mVBOrb.VBOrb.CompletedNO, CStr(newLen) & " > " & CStr(seqBnd))
		End If
		seqIsDim = False
		Me.Length = newLen
		Dim seqCnt As Integer
		For seqCnt = 0 To seqLen - 1
			seqArr(seqCnt) = oAny.getChar_Renamed()
			Call oAny.nextPos()
		Next seqCnt
		Call oAny.rewind()
		Exit Sub
ErrHandler: 
		Call mVBOrb.VBOrb.ErrReraise(Err, "initByAny")
	End Sub
	
	'Helper
	Public Sub insertIntoAny(ByVal oAny As cOrbAny)
		On Error GoTo ErrHandler
		Call oAny.seqSetLength(seqLen)
		Dim seqCnt As Integer
		For seqCnt = 0 To seqLen - 1
			Call oAny.insertChar(seqArr(seqCnt))
			Call oAny.nextPos()
		Next seqCnt
		Call oAny.rewind()
		Exit Sub
ErrHandler: 
		Call mVBOrb.VBOrb.ErrReraise(Err, "insertIntoAny")
	End Sub
End Class